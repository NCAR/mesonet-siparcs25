<!DOCTYPE html>
<html>
<head>
    <title>Real-Time Sensor Network Map</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; padding: 0; }
        #map { height: 100vh; width: 100vw; }
        .station-marker {
            background: #3388ff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            border: 2px solid white;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        .station-popup {
            min-width: 200px;
            font-size: 14px;
        }
        .station-popup h3 {
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        .station-popup table {
            width: 100%;
            border-collapse: collapse;
        }
        .station-popup td {
            padding: 3px 5px;
            border-bottom: 1px solid #eee;
        }
        .station-popup td:first-child {
            font-weight: bold;
        }
        .timestamp {
            font-size: 0.8em;
            color: #777;
            text-align: right;
            margin-top: 5px;
        }
        #error-message {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff4444;
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 1000;
        }
        #loading-message {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 1000;
        }
        #loading-message::before {
            content: '';
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #fff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
            margin-right: 5px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
    <link rel="icon" href="/static/favicon.ico">
</head>
<body>
    <div id="map" aria-label="Interactive sensor network map"></div>
    <div id="error-message"></div>
    <div id="loading-message">Loading...</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script>
        const DEFAULT_LATITUDE = 39.9784;
        const DEFAULT_LONGITUDE = -105.2749;
        const locale = navigator.language || 'en-US';
        const map = L.map('map').setView([DEFAULT_LATITUDE, DEFAULT_LONGITUDE], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        const stations = {};
        const markers = {};
        const errorMessage = document.getElementById('error-message');
        const loadingMessage = document.getElementById('loading-message');

        function handleError(message, error) {
            console.error(message, error);
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
            setTimeout(() => { errorMessage.style.display = 'none'; }, 10000);
        }

        function showLoading(show) {
            loadingMessage.style.display = show ? 'block' : 'none';
        }

        function escapeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str ?? 'N/A';
            return div.innerHTML;
        }

        function createMarkerIcon(stationId) {
            return L.divIcon({
                className: 'station-marker',
                html: escapeHTML(stationId),
                iconSize: [24, 24],
                iconAnchor: [12, 12],
                popupAnchor: [0, -12]
            });
        }

        function createPopupContent(stationId, stationData) {
            const timestamp = stationData.last_active
                ? stationData.last_active
                : 'Unknown';
            let html = `<div class="station-popup" role="dialog" aria-label="Station ${escapeHTML(stationId)} details"><h3>Station ${escapeHTML(stationId)}</h3><table>`;
            for (const [key, value] of Object.entries(stationData)) {
                html += `<tr><td>${escapeHTML(key)}</td><td>${escapeHTML(value)}</td></tr>`;
            }
            html += `</table><div class="timestamp">Last updated: ${timestamp}</div></div>`;
            return html;
        }

        function updateStationMarker(stationId, stationData) {
            console.log(`Updating station ${stationId}:`, stationData);
            if (!stationData || typeof stationData !== 'object') {
                handleError(`Invalid station data for ${stationId}`);
                return;
            }
            if (!stationData.latitude || !stationData.longitude || 
                isNaN(stationData.latitude) || isNaN(stationData.longitude)) {
                handleError(`Station ${stationId} has invalid coordinates`);
                return;
            }
            const latLng = [stationData.latitude, stationData.longitude];
            if (markers[stationId]) {
                const existingData = markers[stationId].options.data || {};
                const { last_active, ...dataWithoutTimestamp } = stationData;
                const { last_active: oldTimestamp, ...existingWithoutTimestamp } = existingData;
                const newPopupContent = createPopupContent(stationId, stationData);
                if (!_.isEqual(dataWithoutTimestamp, existingWithoutTimestamp) || 
                    markers[stationId].getPopup()?.getContent() !== newPopupContent) {
                    markers[stationId].setLatLng(latLng);
                    markers[stationId].setPopupContent(newPopupContent);
                    markers[stationId].options.data = stationData;
                }
            } else {
                markers[stationId] = L.marker(latLng, {
                    icon: createMarkerIcon(stationId),
                    data: stationData
                })
                .addTo(map)
                .bindPopup(createPopupContent(stationId, stationData));
                const bounds = Object.values(markers).map(marker => marker.getLatLng());
                if (bounds.length > 1) {
                    map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
                }
            }
        }

        function cleanupStaleMarkers() {
            Object.keys(markers).forEach(id => {
                if (!stations[id]) {
                    map.removeLayer(markers[id]);
                    delete markers[id];
                }
            });
        }

        async function fetchInitialData() {
            showLoading(true);
            try {
                const response = await fetch('/api/stations');
                if (!response.ok) throw new Error(`Initial fetch failed: ${response.status}`);
                const data = await response.json();
                console.log('Received initial station data:', data);
                if (data && data.stations) {
                    Object.entries(data.stations).forEach(([id, stationData]) => {
                        stations[id] = stationData;
                        updateStationMarker(id, stationData);
                    });
                }
            } catch (error) {
                handleError('Failed to load initial station data', error);
            } finally {
                showLoading(false);
            }
        }

        function setupSocketHandlers(socket) {
            socket.on('initial_data', data => {
                console.log('Received Socket.IO initial data:', data);
                if (data && data.stations) {
                    Object.entries(data.stations).forEach(([id, stationData]) => {
                        stations[id] = stationData;
                        updateStationMarker(id, stationData);
                    });
                }
            });

            socket.on('station_update', data => {
                if (!data || !data.station_id || typeof data.latitude !== 'number' || typeof data.longitude !== 'number') {
                    handleError('Invalid station update data');
                    return;
                }
                stations[data.station_id] = data;
                updateStationMarker(data.station_id, data);
            });

            socket.on('station_remove', data => {
                console.log('Removing station:', data);
                if (markers[data.station_id]) {
                    map.removeLayer(markers[data.station_id]);
                    delete markers[data.station_id];
                }
                delete stations[data.station_id];
            });
        }

        async function initializeSocketIO() {
            let socketUrl ='http://localhost:5001';
            try {
                const response = await fetch('/api/config');
                if (!response.ok) throw new Error(`Config fetch failed: ${response.status}`);
                const config = await response.json();
                socketUrl = `http://${config['map']['host']}:${config['map']['port']}`;
            } catch (error) {
                handleError('Failed to load server config', error);
            }

            const socket = io(socketUrl, { 
                transports: ['websocket'],
                reconnection: true,
                reconnectionAttempts: Infinity,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                withCredentials: true
            });
            socket.on('connect_error', (err) => {
                handleError('Failed to connect to real-time server', err);
            });
            setupSocketHandlers(socket);
            return socket;
        }

        // Initialize map with immediate data fetch
        (async () => {
            await fetchInitialData();
            const socket = await initializeSocketIO();
            console.log('Socket.IO initialized');
            const refreshInterval = 5000;
            setInterval(async () => {
                try {
                    const response = await fetch('/api/stations');
                    if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
                    const data = await response.json();
                    console.log('Received periodic station data:', data);
                    if (data && data.stations) {
                        Object.entries(data.stations).forEach(([id, stationData]) => {
                            if (!stations[id] || !_.isEqual(stations[id], stationData)) {
                                stations[id] = stationData;
                                updateStationMarker(id, stationData);
                            }
                        });
                        Object.keys(stations).forEach(id => {
                            if (!data.stations[id]) {
                                if (markers[id]) {
                                    map.removeLayer(markers[id]);
                                    delete markers[id];
                                }
                                delete stations[id];
                            }
                        });
                    }
                } catch (error) {
                    handleError('Failed to fetch station data', error);
                }
            }, refreshInterval);
            setInterval(cleanupStaleMarkers, 60000); // Run cleanup every minute
        })();
    </script>
</body>
</html>