<!DOCTYPE html>
<html lang="en">
<head>
    <title>Real-Time Sensor Network Map</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <style>
        body { margin: 0; padding: 0; }
        #map { height: 100vh; width: 100vw; }
        
        .station-marker {
            background: #3388ff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            border: 2px solid white;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        
        .station-popup {
            min-width: 250px;
            max-width: 350px;
            font-size: 14px;
            overflow-y: auto;
            max-height: 70vh;
        }
        .station-popup h3 {
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
        }
        .station-popup table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 10px;
        }
        .station-popup td {
            padding: 3px 5px;
            border-bottom: 1px solid #eee;
        }
        .station-popup td:first-child {
            font-weight: bold;
            width: 40%;
        }
        .timestamp {
            font-size: 0.8em;
            color: #777;
            text-align: right;
            margin-top: 5px;
            position: sticky;
            bottom: 0;
            background: white;
            padding-top: 5px;
            border-top: 1px solid #eee;
        }
        
        .popup-controls {
            position: absolute;
            top: 5px;
            right: 5px;
            z-index: 20;
            display: flex;
            gap: 3px;
        }
        .popup-controls button {
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.1s ease-out;
        }
        .popup-controls button:hover {
            background: #f0f0f0;
        }
        .close-popup {
            color: #ff4444;
        }
        .pin-popup {
            color: #555;
        }
        .pin-popup.pinned {
            background: #3388ff !important;
            color: white !important;
            border-color: #3388ff !important;
        }
        .pin-popup.pinned:hover {
            background: #2a6fcc !important;
            border-color: #2a6fcc !important;
        }
        
        #error-message {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff4444;
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 1001;
            max-width: 80%;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        #loading-message {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 1000;
            max-width: 80%;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        #loading-message::before {
            content: '';
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #fff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
            margin-right: 5px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .collapsible {
            cursor: pointer;
            padding: 5px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            margin: 5px 0;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .collapsible:hover {
            background: #e0e0e0;
        }
        .collapsible::after {
            content: '+';
            font-weight: bold;
        }
        .collapsible.active::after {
            content: '-';
        }
        .content {
            display: none;
            padding: 5px;
            margin-left: 10px;
            border-left: 2px solid #ddd;
        }
        .content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div id="map" aria-label="Interactive sensor network map"></div>
    <div id="error-message" role="alert"></div>
    <div id="loading-message">Loading...</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        const DEFAULT_LATITUDE = 39.9784;
        const DEFAULT_LONGITUDE = -105.2749;
        const locale = navigator.language || 'en-US';
        
        const map = L.map('map').setView([DEFAULT_LATITUDE, DEFAULT_LONGITUDE], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        const stations = {};
        const markerMap = {};
        const activePopups = new Set();
        const expandedSectionsState = {};

        const markers = L.markerClusterGroup({
            maxClusterRadius: 40,
            spiderfyOnMaxZoom: true,
            showCoverageOnHover: true,
            zoomToBoundsOnClick: true,
            iconCreateFunction: function(cluster) {
                const count = cluster.getChildCount();
                const size = Math.min(40 + Math.log(count) * 10, 60);
                return L.divIcon({
                    html: `<div>${count}</div>`,
                    className: 'marker-cluster marker-cluster-small',
                    iconSize: L.point(size, size)
                });
            }
        });
        map.addLayer(markers);

        const errorMessage = document.getElementById('error-message');
        const loadingMessage = document.getElementById('loading-message');

        function handleError(message, error) {
            console.error(`[error] ${message}`, error);
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
            setTimeout(() => { errorMessage.style.display = 'none'; }, 10000);
        }

        function showLoading(show) {
            loadingMessage.style.display = show ? 'block' : 'none';
        }

        function escapeHTML(str) {
            if (str == null) return 'N/A';
            return str.toString()
                .replace(/&/g, '&')
                .replace(/</g, '<')
                .replace(/>/g, '>')
                .replace(/"/g, '"')
                .replace(/'/g, "'");
        }

        function createMarkerIcon(stationId) {
            return L.divIcon({
                className: 'station-marker',
                html: escapeHTML(stationId),
                iconSize: [24, 24],
                iconAnchor: [12, 12],
                popupAnchor: [0, -12]
            });
        }

        function createPopupContent(stationId, stationData) {
            let html = `<div class="station-popup" role="dialog" aria-label="Station ${escapeHTML(stationId)} details">
                <div class="popup-controls">
                    <button class="close-popup" title="Close" aria-label="Close popup">Ã—</button>
                    <button class="pin-popup" title="Pin popup (keep open)" aria-label="Pin popup">ðŸ“Œ</button>
                </div>
                <h3>Station ${escapeHTML(stationId)}</h3>`;

            let sensorData = {};
            let modelSummaries = {};
            let metadata = {};
            
            try {
                sensorData = JSON.parse(stationData.data || '{}').data || {};
                modelSummaries = JSON.parse(stationData.model_summaries || '{}');
                metadata = JSON.parse(stationData.metadata || '{}');
            } catch (e) {
                console.error(`[error] Parsing error for station ${stationId}`, e);
                html += `<p>Error parsing station data</p>`;
                return html + '</div>';
            }

            const metadataExpanded = expandedSectionsState[stationId]?.metadata || false;
            html += `<div class="collapsible ${metadataExpanded ? 'active' : ''}" data-section="metadata">Metadata</div>
                    <div class="content ${metadataExpanded ? 'active' : ''}">
                        <table>
                            <tr><td>station_id</td><td>${escapeHTML(stationId)}</td></tr>
                            <tr><td>latitude</td><td>${escapeHTML(stationData.latitude || 'N/A')}</td></tr>
                            <tr><td>longitude</td><td>${escapeHTML(stationData.longitude || 'N/A')}</td></tr>`;
            
            for (const [key, value] of Object.entries(metadata)) {
                html += `<tr><td>${escapeHTML(key)}</td><td>${escapeHTML(value)}</td></tr>`;
            }
            
            html += `</table>`;
            
            if (stationData.last_active) {
                try {
                    const lastUpdated = new Date(stationData.last_active);
                    if (isNaN(lastUpdated.getTime())) {
                        throw new Error('Invalid date');
                    }
                    html += `<div class="timestamp">Last updated: ${escapeHTML(lastUpdated.toLocaleString(locale))}</div>`;
                } catch (e) {
                    console.error(`[error] Failed to format last_active for station ${stationId}`, e);
                    html += `<div class="timestamp">Last updated: N/A</div>`;
                }
            }
            
            html += `</div>`;

            if (Object.keys(sensorData).length > 0) {
                for (const [sensor, measurements] of Object.entries(sensorData)) {
                    const sensorExpanded = expandedSectionsState[stationId]?.[sensor] || false;
                    html += `<div class="collapsible ${sensorExpanded ? 'active' : ''}" data-section="${escapeHTML(sensor)}">${escapeHTML(sensor)}</div>
                            <div class="content ${sensorExpanded ? 'active' : ''}"><table>`;
                    
                    for (const [measurement, value] of Object.entries(measurements)) {
                        html += `<tr><td>${escapeHTML(measurement)}</td><td>${escapeHTML(value)}</td></tr>`;
                    }
                    
                    html += `</table></div>`;
                }
            }

            const summariesExpanded = expandedSectionsState[stationId]?.summaries || false;
            html += `<div class="collapsible ${summariesExpanded ? 'active' : ''}" data-section="summaries">Model Summaries</div>
                    <div class="content ${summariesExpanded ? 'active' : ''}>`;
            
            if (Object.keys(modelSummaries).length > 0) {
                html += `<table>`;
                for (const [key, value] of Object.entries(modelSummaries)) {
                    const modelName = key.replace('summary_', '').replace('ai/', '');
                    html += `<tr><td>${escapeHTML(modelName)}</td><td>${escapeHTML(value)}</td></tr>`;
                }
                html += `</table>`;
            } else {
                html += `<p>No model summaries available</p>`;
            }
            
            html += `</div></div>`;
            return html;
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function setupPopupControls(popup, marker) {
            const popupElement = popup.getElement();
            const closeBtn = popupElement.querySelector('.close-popup');
            const pinBtn = popupElement.querySelector('.pin-popup');
            const listeners = [];

            if (marker.options.keepOpen) {
                pinBtn.classList.add('pinned');
                pinBtn.setAttribute('aria-pressed', 'true');
                pinBtn.title = 'Unpin popup';
            } else {
                pinBtn.classList.remove('pinned');
                pinBtn.setAttribute('aria-pressed', 'false');
                pinBtn.title = 'Pin popup (keep open)';
            }

            if (closeBtn) {
                const closeHandler = (e) => {
                    e.stopPropagation();
                    marker.options.keepOpen = false; // Unpin when closing
                    popup.remove();
                    activePopups.delete(marker);
                };
                closeBtn.addEventListener('click', closeHandler);
                listeners.push({ element: closeBtn, event: 'click', handler: closeHandler });
            }

            if (pinBtn) {
                const pinHandler = (e) => {
                    e.stopPropagation();
                    const isPinned = !marker.options.keepOpen;
                    
                    // Update marker options
                    marker.options.keepOpen = isPinned;

                    // Update pin button appearance and attributes
                    pinBtn.classList.toggle('pinned', isPinned);
                    pinBtn.setAttribute('aria-pressed', isPinned.toString());
                    pinBtn.title = isPinned ? 'Unpin popup' : 'Pin popup (keep open)';

                    // Rebind popup with new options
                    const popupContent = popup.getContent();
                    marker.unbindPopup();
                    marker.bindPopup(popupContent, {
                        maxWidth: 350,
                        minWidth: 250,
                        autoClose: !isPinned,
                        closeOnClick: !isPinned,
                        closeButton: !isPinned,
                        className: 'station-popup-container'
                    });

                    // Ensure popup stays open if pinned
                    if (isPinned) {
                        marker.openPopup();
                        map.once('click', () => {
                            if (marker.options.keepOpen) {
                                marker.openPopup();
                            }
                        });
                    }
                };
                pinBtn.addEventListener('click', pinHandler);
                listeners.push({ element: pinBtn, event: 'click', handler: pinHandler });
            }

            const collapsibles = popupElement.getElementsByClassName('collapsible');
            Array.from(collapsibles).forEach(collapsible => {
                const collapsibleHandler = function(e) {
                    e.stopPropagation();
                    const sectionName = collapsible.getAttribute('data-section');
                    const isActive = collapsible.classList.contains('active');
                    
                    // Toggle active class on collapsible and content
                    collapsible.classList.toggle('active');
                    const content = collapsible.nextElementSibling;
                    if (content && content.classList.contains('content')) {
                        content.classList.toggle('active', !isActive);
                    }

                    // Update state
                    if (!expandedSectionsState[marker.options.layerId]) {
                        expandedSectionsState[marker.options.layerId] = {};
                    }
                    expandedSectionsState[marker.options.layerId][sectionName] = !isActive;
                };
                collapsible.addEventListener('click', collapsibleHandler);
                listeners.push({ element: collapsible, event: 'click', handler: collapsibleHandler });
            });

            marker.cleanupPopup = () => {
                listeners.forEach(({ element, event, handler }) => {
                    element.removeEventListener(event, handler);
                });
            };
        }

        function updateStationMarker(stationId, stationData) {
            if (!stationData || !stationData.latitude || !stationData.longitude) {
                handleError(`Invalid data for station ${stationId}`);
                return;
            }

            stations[stationId] = stationData;
            const latLng = [parseFloat(stationData.latitude), parseFloat(stationData.longitude)];

            let wasPinned = false;
            if (markerMap[stationId]) {
                wasPinned = markerMap[stationId].options.keepOpen || false;
                if (markerMap[stationId].cleanupPopup) {
                    markerMap[stationId].cleanupPopup();
                }
                markers.removeLayer(markerMap[stationId]);
                activePopups.delete(markerMap[stationId]);
            }

            const newPopupContent = createPopupContent(stationId, stationData);
            const marker = L.marker(latLng, {
                icon: createMarkerIcon(stationId),
                data: stationData,
                layerId: stationId,
                keepOpen: wasPinned
            }).bindPopup(newPopupContent, {
                maxWidth: 350,
                minWidth: 250,
                autoClose: !wasPinned,
                closeOnClick: !wasPinned,
                closeButton: !wasPinned,
                className: 'station-popup-container'
            });

            const adjustMapView = debounce(() => {
                const popupElement = marker.getPopup()?.getElement();
                if (popupElement) {
                    const popupRect = popupElement.getBoundingClientRect();
                    const mapRect = map.getContainer().getBoundingClientRect();
                    
                    if (popupRect.right > mapRect.right || popupRect.bottom > mapRect.bottom) {
                        map.panBy([
                            Math.min(0, mapRect.right - popupRect.right - 10),
                            Math.min(0, mapRect.bottom - popupRect.bottom - 10)
                        ], { animate: true });
                    }
                }
            }, 100);

            marker.on('popupopen', () => {
                const popup = marker.getPopup();
                setupPopupControls(popup, marker);
                activePopups.add(marker);
                adjustMapView();
            });

            marker.on('popupclose', () => {
                marker.options.keepOpen = false; // Unpin when popup is closed
                activePopups.delete(marker);
                if (marker.cleanupPopup) {
                    marker.cleanupPopup();
                }
            });

            markers.addLayer(marker);
            markerMap[stationId] = marker;

            // Reopen popup if it was pinned
            if (wasPinned) {
                marker.openPopup();
            }
        }

        function cleanupStaleMarkers() {
            const markerIds = new Set(Object.keys(stations));
            Object.keys(markerMap).forEach(id => {
                if (!markerIds.has(id)) {
                    if (markerMap[id].cleanupPopup) {
                        markerMap[id].cleanupPopup();
                    }
                    markers.removeLayer(markerMap[id]);
                    activePopups.delete(markerMap[id]);
                    delete markerMap[id];
                    delete expandedSectionsState[id];
                }
            });
        }

        async function fetchInitialData() {
            showLoading(true);
            try {
                const response = await fetch('/api/stations');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                
                if (!data?.stations || typeof data.stations !== 'object') {
                    throw new Error('Invalid station data format');
                }

                Object.entries(data.stations).forEach(([id, stationData]) => {
                    stations[id] = stationData;
                    updateStationMarker(id, stationData);
                });
                cleanupStaleMarkers();
            } catch (error) {
                handleError('Failed to load initial station data', error);
            } finally {
                showLoading(false);
            }
        }

        function setupSocketHandlers(socket) {
            socket.on('initial_data', data => {
                if (!data?.stations || typeof data.stations !== 'object') {
                    handleError('Invalid initial data from socket');
                    return;
                }
                Object.entries(data.stations).forEach(([id, stationData]) => {
                    stations[id] = stationData;
                    updateStationMarker(id, stationData);
                });
                cleanupStaleMarkers();
            });

            socket.on('station_update', data => {
                if (!data || !data.station_id || !data.latitude || !data.longitude) {
                    handleError('Invalid station update data');
                    console.error('[station_update] Invalid data:', data);
                    return;
                }
                stations[data.station_id] = data;
                updateStationMarker(data.station_id, data);
            });

            socket.on('station_remove', data => {
                if (!data?.station_id) {
                    handleError('Invalid station removal data');
                    return;
                }
                if (stations[data.station_id]) {
                    delete stations[data.station_id];
                    cleanupStaleMarkers();
                }
            });
        }

        async function initializeSocketIO() {
            const socketUrl = window.location.hostname === 'localhost' 
                ? 'http://localhost:5001' 
                : `${window.location.protocol}//${window.location.host}`;
            
            const socket = io(socketUrl, { 
                transports: ['websocket'],
                reconnection: true,
                reconnectionAttempts: Infinity,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                withCredentials: true
            });
            
            socket.on('connect_error', (err) => {
                handleError(`Socket.IO connection failed: ${err.message}`, err);
            });
            
            socket.on('connect', () => {
                console.log('[info] Connected to Socket.IO server');
            });
            
            setupSocketHandlers(socket);
            return socket;
        }

        (async () => {
            await fetchInitialData();
            const socket = await initializeSocketIO();
            
            setInterval(async () => {
                try {
                    const response = await fetch('/api/stations');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const data = await response.json();
                    
                    if (!data?.stations || typeof data.stations !== 'object') {
                        throw new Error('Invalid station data format');
                    }
                    
                    Object.entries(data.stations).forEach(([id, stationData]) => {
                        stations[id] = stationData;
                        updateStationMarker(id, stationData);
                    });
                    
                    Object.keys(stations).forEach(id => {
                        if (!data.stations[id]) {
                            delete stations[id];
                            if (markerMap[id]) {
                                if (markerMap[id].cleanupPopup) {
                                    markerMap[id].cleanupPopup();
                                }
                                markers.removeLayer(markerMap[id]);
                                activePopups.delete(markerMap[id]);
                                delete markerMap[id];
                                delete expandedSectionsState[id];
                            }
                        }
                    });
                } catch (error) {
                    handleError('Failed to fetch station data', error);
                }
            }, 30000);

            setInterval(cleanupStaleMarkers, 10000);
        })();
    </script>
</body>
</html>